package com.kindustry.network.util;

import java.util.ArrayList;
import java.util.List;

import org.htmlparser.Node;
import org.htmlparser.NodeFilter;
import org.htmlparser.Parser;
import org.htmlparser.nodes.TagNode;
import org.htmlparser.nodes.TextNode;
import org.htmlparser.tags.ImageTag;
import org.htmlparser.util.NodeList;
import org.htmlparser.util.ParserException;

public class ParseUtils {
	
	/**
	 * 提取具有某个属性值的标签列表
	 * @param <T> 自定义一种泛型表示其是TagNode的子类
	 * @param html 被提取的HTML文本
	 * @param tagType 标签类型
	 * @param attributeName 某个属性的名称
	 * @param attributeValue 属性应取的值, 符合这种属性值的标签拿出来, 如果有特定属性值的话, 那么就应该返回的某一个特定的TagNode类型了
	 * @return
	 */
	public static <T extends TagNode> List<T> parseTags(String html,final Class<T> tagType,final String attributeName,final String attributeValue){
		try {
			//创建一个HTML解释器
			Parser parser = new Parser();
			parser.setInputHTML(html);

			NodeList tagList = parser.parse(
				new NodeFilter(){
					@Override
					public boolean accept(Node node) {
						
						if(node.getClass() == tagType){
							T tn = (T)node;
							//这种做法用于: 当属性名为空的情况下
							//不想根据具体标签名和标签值来进行查找,而只想根据指定的类型来进行查找
							if(attributeName == null){
								return true;
							}
							
							String attrValue = tn.getAttribute(attributeName);
							if(attrValue != null && attrValue.equals(attributeValue)){
								return true;
							}
						}

						return false;
					}
				}
			);
			
			List<T> tags = new ArrayList<T>();
			for(int i=0; i<tagList.size(); i++){
				T t = (T)tagList.elementAt(i);
				tags.add(t);
			}
			
			return tags;
		} catch (ParserException e) {
			e.printStackTrace();
		}
		return null;
	}
	
	public static <T extends TagNode> List<T> parseTags(String html,final Class<T> tagType){
		return parseTags(html, tagType,null,null);
	}
	
	public static <T extends TagNode> T parseTag(String html,final Class<T> tagType,final String attributeName,final String attributeValue){
		List<T> tags = parseTags(html, tagType, attributeName, attributeValue);
		if(tags != null && tags.size() > 0){
			return tags.get(0);
		}
		return null;
	}
	
	public static <T extends TagNode> T parseTag(String html,final Class<T> tagType){
		return parseTag(html, tagType,null,null);
	}
	
	/**
	 * 修改HTML内容中所包含的所有图片的链接地址，加上指定的前缀
	 * @param html 要被修改的HTML内容
	 * @param prefix 要增加的前缀
	 * @return 被修改之后的HTML内容
	 */
	public static String modifyImageUrl(String html,String prefix){
		try {
			
			StringBuffer sb = new StringBuffer();
			
			//创建一个HTML解释器
			Parser parser = new Parser();
			parser.setInputHTML(html);
			
			//nodeList中，将包含网页中的所有内容
			NodeList nodeList = parser.parse(
				new NodeFilter(){
					public boolean accept(Node node) {
						return true;
					}
				}
			);
			
			for(int i=0; i<nodeList.size(); i++){
				Node node = nodeList.elementAt(i);
				if(node instanceof ImageTag){
					//如果是<img>标签
					ImageTag it = (ImageTag)node;
					it.setImageURL(prefix + it.getImageURL());
					sb.append(it.toHtml());
				}else if(node instanceof TextNode){ //文本标签，原样输出
					TextNode text = (TextNode)node;
					sb.append(text.getText());
				}else{ //其它所有标签，原样输出
					sb.append("<");
					sb.append(node.getText());
					sb.append(">");
				}
			}
			
			return sb.toString();
		} catch (ParserException e) {
			e.printStackTrace();
		}
		return null;
	}	
}
